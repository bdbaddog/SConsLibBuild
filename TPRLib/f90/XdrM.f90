      MODULE Xdr
!
! -------------------- NOTE: DO NOT EDIT THIS FILE. --------------------
! This file is generated.  Modifications will be lost!
! ----------------------------------------------------------------------
!
!     BEGIN MODULE USE
      USE PibIntrType
      USE CPibFaces
!
      CONTAINS
!
!-------------------------------------------------
!  Read an integer from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value read from the file.
!
      SUBROUTINE READ_XDR_INT(err,fnum,val)
      IMPLICIT NONE
      INTEGER(ptik) :: err,fnum,val
      CALL CReadXdrInt(err,fnum, val)
      END SUBROUTINE READ_XDR_INT
!
!-------------------------------------------------
!  Read a 64-bit integer from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value read from the file.
!
      SUBROUTINE READ_XDR_INT64(err,fnum,val)
      IMPLICIT NONE
      INTEGER(ptik) :: err,fnum
      INTEGER(ptlk) :: val
      CALL CReadXdrInt64(err,fnum, val)
      END SUBROUTINE READ_XDR_INT64
!
!-------------------------------------------------
!  Read a logical from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value read from the file.
!
      SUBROUTINE READ_XDR_LOGICAL(err,fnum,val)
      IMPLICIT NONE
      INTEGER(ptik) :: err,fnum,i
      LOGICAL :: val
      CALL CReadXdrInt(err,fnum, i)
      val = (i.ne.0)
      END SUBROUTINE READ_XDR_LOGICAL
!
!-------------------------------------------------
!  Read a float from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value read from the file.
!
      SUBROUTINE READ_XDR_FLOAT(err,fnum,val)
      IMPLICIT NONE
      INTEGER(ptik) :: err,fnum
      REAL :: val
      CALL CReadXdrFloat(err,fnum, val)
      END SUBROUTINE READ_XDR_FLOAT
!
!-------------------------------------------------
!  Read a double from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value read from the file.
!
      SUBROUTINE READ_XDR_DOUBLE(err,fnum,val)
      REAL(ptdk) :: val
      INTEGER(ptik) :: err,fnum
      CALL CReadXdrDouble(err,fnum, val)
      END SUBROUTINE READ_XDR_DOUBLE
!
!-------------------------------------------------
!  Read a String from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value read from the file.
!  @param length The maximum length of the string.
!
      SUBROUTINE READ_XDR_STRING(err,fnum,val,length)
      IMPLICIT NONE
      INTEGER(ptik) :: err,fnum,length,firstNull
      CHARACTER(LEN=length) ::  val
      CHARACTER(LEN=length+1) ::  tval
      CALL CReadXdrString(err,fnum,tval,length)
      val = tval(1:length)
      firstNull = INDEX(val,CHAR(0))
      IF(firstNull .GT. 0 ) THEN
         val(firstNULL:) = ' '
      ENDIF
      END SUBROUTINE READ_XDR_STRING
!
!-------------------------------------------------
!  Read a Raw Byte array from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value read from the file.
!  @param length The maximum length of the byte array.
!
      SUBROUTINE READ_XDR_BYTES(err,fnum,val,length)
      IMPLICIT NONE
      INTEGER(ptik) :: err,fnum,length
      CHARACTER(LEN=length) ::  val
      CALL CReadXdrBytes(err,fnum,val,length)
      END SUBROUTINE READ_XDR_BYTES
!
!-------------------------------------------------
!  Read an array of integers from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_INTARR(err,fnum,arr)
!
      IMPLICIT NONE
      INTEGER(ptik),POINTER :: arr(:)
      INTEGER(ptik) err,fnum,len
!
      CALL CReadXdrArrSize(err,fnum,len)
      IF (err .ne. 0) RETURN
      IF (len .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE(arr(len))
         IF(len > 0) THEN
            CALL CReadXdrIntArr(err,fnum,len,arr)
         ENDIF
      ENDIF
!
      END SUBROUTINE READ_XDR_INTARR
!
!-------------------------------------------------
!  Read an array of logicals from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_LOGICALARR(err,fnum,arr)
!
      IMPLICIT NONE
      INTEGER(ptik) err,fnum,len,I
      LOGICAL,POINTER :: arr(:)
!
      CALL CReadXdrInt(err,fnum,len)
      IF (err .ne. 0) RETURN
      IF (len .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE(arr(len))
         DO I = 1, len
           CALL READ_XDR_LOGICAL(err,fnum,arr(I))
           IF (err .ne. 0) RETURN
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_LOGICALARR
!
!-------------------------------------------------
!  Read an array of floats from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_FLOATARR(err,fnum,arr)
!
      IMPLICIT NONE
      REAL, POINTER, DIMENSION(:) :: arr
      INTEGER(ptik) err,fnum,i,len
!
      CALL CReadXdrArrSize(err,fnum,len)
      IF (err .ne. 0) RETURN
      IF (len .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE(arr(len))
         IF (len > 0 ) THEN
            CALL CReadXdrFloatArr(err,fnum,len,arr)
         ENDIF
      ENDIF
!
      END SUBROUTINE READ_XDR_FLOATARR
!
!-------------------------------------------------
!  Read an array of doubles from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_DOUBLEARR(err,fnum,arr)
!
      IMPLICIT NONE
      REAL(ptdk), POINTER, DIMENSION(:) :: arr
      INTEGER(ptik) err,fnum,i,len
!
      CALL CReadXdrArrSize(err,fnum,len)
      IF (err .ne. 0) RETURN
      IF (len .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE(arr(len))
         IF (len > 0 ) THEN
            CALL CReadXdrDoubleArr(err,fnum,len,arr)
         ENDIF
      ENDIF
!
      END SUBROUTINE READ_XDR_DOUBLEARR
!
!-------------------------------------------------
!  Read an array of Strings from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file.
!  @param length The maximum length of the string.
!
      SUBROUTINE READ_XDR_STRINGARR(err,fnum,arr,length)
!
      IMPLICIT NONE
      INTEGER(ptik) :: err,fnum,length,i,numElements,firstNull
      CHARACTER(LEN=length),POINTER,DIMENSION(:) :: arr
!
      CALL READ_XDR_INT(err,fnum, numElements)
      IF (err.ne.0) RETURN
      IF (length .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE(arr(numElements))
         DO i = 1, numElements
            CALL READ_XDR_STRING(err,fnum,arr(i),length)
            IF (err.ne.0) RETURN
            firstNull = INDEX(arr(i),CHAR(0))
            IF(firstNull .GT. 0 ) THEN
               arr(i)(firstNULL:) = ' '
            ENDIF
         ENDDO
      ENDIF
      END SUBROUTINE READ_XDR_STRINGARR
!
!-------------------------------------------------
!  Read a rank 2 array of integers from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R2INTARR(err,fnum,arr)
!
      IMPLICIT NONE
      INTEGER(ptik),POINTER :: arr(:,:)
      INTEGER(ptik) err,fnum,rank,I,J,sizeI,sizeJ,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne.2) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. sizeI*sizeJ) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ))
         DO I = 1, sizeI
           DO J = 1, sizeJ
            CALL CReadXdrInt(err,fnum,arr(I,J))
            IF (err.ne.0) RETURN
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R2INTARR
!
!-------------------------------------------------
!  Read a rank 3 array of integers from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R3INTARR(err,fnum,arr)
!
      IMPLICIT NONE
      INTEGER(ptik),POINTER :: arr(:,:,:)
      INTEGER(ptik) err,fnum,rank,I,J,K,sizeI,sizeJ,sizeK,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne.3) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeK)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. (sizeI*sizeJ*sizeK)) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ,sizeK))
         DO I = 1, sizeI
           DO J = 1, sizeJ
             DO K = 1, sizeK
              CALL CReadXdrInt(err,fnum,arr(I,J,K))
              IF (err.ne.0) RETURN
             ENDDO
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R3INTARR
!
!-------------------------------------------------
!  Read a rank 4 array of integers from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R4INTARR(err,fnum,arr)
!
      IMPLICIT NONE
      INTEGER(ptik),POINTER :: arr(:,:,:,:)
      INTEGER(ptik) err,fnum,rank,I,J,K,L,sizeI,sizeJ,sizeK,sizeL,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne. 4) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeK)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeL)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. (sizeI*sizeJ*sizeK*sizeL)) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ,sizeK,sizeL))
         DO I = 1, sizeI
           DO J = 1, sizeJ
             DO K = 1, sizeK
               DO L = 1, sizeL
                CALL CReadXdrInt(err,fnum,arr(I,J,K,L))
                IF (err.ne.0) RETURN
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R4INTARR
!
!-------------------------------------------------
!  Read a rank 2 array of logicals from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R2LOGICALARR(err,fnum,arr)
!
      IMPLICIT NONE
      LOGICAL,POINTER :: arr(:,:)
      INTEGER(ptik) err,fnum,rank,I,J,sizeI,sizeJ,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne.2) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. sizeI*sizeJ) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ))
         DO I = 1, sizeI
           DO J = 1, sizeJ
            CALL READ_XDR_LOGICAL(err,fnum, arr(I,J))
            IF (err.ne.0) RETURN
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R2LOGICALARR
!
!-------------------------------------------------
!  Read a rank 3 array of logicals from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R3LOGICALARR(err,fnum,arr)
!
      IMPLICIT NONE
      LOGICAL,POINTER :: arr(:,:,:)
      INTEGER(ptik) err,fnum,rank,I,J,K,sizeI,sizeJ,sizeK,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne.3) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeK)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. (sizeI*sizeJ*sizeK)) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ,sizeK))
         DO I = 1, sizeI
           DO J = 1, sizeJ
             DO K = 1, sizeK
              CALL READ_XDR_LOGICAL(err,fnum, arr(I,J,K))
              IF (err.ne.0) RETURN
             ENDDO
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R3LOGICALARR
!
!-------------------------------------------------
!  Read a rank 4 array of logicals from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R4LOGICALARR(err,fnum,arr)
!
      IMPLICIT NONE
      LOGICAL,POINTER :: arr(:,:,:,:)
      INTEGER(ptik) err,fnum,rank,I,J,K,L,sizeI,sizeJ,sizeK,sizeL,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne. 4) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeK)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeL)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. (sizeI*sizeJ*sizeK*sizeL)) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ,sizeK,sizeL))
         DO I = 1, sizeI
           DO J = 1, sizeJ
             DO K = 1, sizeK
               DO L = 1, sizeL
                CALL READ_XDR_LOGICAL(err,fnum, arr(I,J,K,L))
                IF (err.ne.0) RETURN
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R4LOGICALARR
!
!-------------------------------------------------
!  Read a rank 2 array of floats from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R2FLOATARR(err,fnum,arr)
!
      IMPLICIT NONE
      REAL, POINTER :: arr(:,:)
      INTEGER(ptik) err,fnum,rank,I,J,sizeI,sizeJ,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne.2) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. sizeI*sizeJ) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ))
         DO I = 1, sizeI
           DO J = 1, sizeJ
            CALL CReadXdrFloat(err,fnum,arr(I,J))
            IF (err.ne.0) RETURN
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R2FLOATARR
!
!-------------------------------------------------
!  Read a rank 3 array of floats from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R3FLOATARR(err,fnum,arr)
!
      IMPLICIT NONE
      REAL, POINTER :: arr(:,:,:)
      INTEGER(ptik) err,fnum,rank,I,J,K,sizeI,sizeJ,sizeK,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne.3) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeK)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. (sizeI*sizeJ*sizeK)) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ,sizeK))
         DO I = 1, sizeI
           DO J = 1, sizeJ
             DO K = 1, sizeK
              CALL CReadXdrFloat(err,fnum,arr(I,J,K))
              IF (err.ne.0) RETURN
             ENDDO
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R3FLOATARR
!
!-------------------------------------------------
!  Read a rank 4 array of floats from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R4FLOATARR(err,fnum,arr)
!
      IMPLICIT NONE
      REAL, POINTER :: arr(:,:,:,:)
      INTEGER(ptik) err,fnum,rank,I,J,K,L,sizeI,sizeJ,sizeK,sizeL,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne. 4) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeK)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeL)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. (sizeI*sizeJ*sizeK*sizeL)) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ,sizeK,sizeL))
         DO I = 1, sizeI
           DO J = 1, sizeJ
             DO K = 1, sizeK
               DO L = 1, sizeL
                CALL CReadXdrFloat(err,fnum,arr(I,J,K,L))
                IF (err.ne.0) RETURN
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R4FLOATARR
!
!-------------------------------------------------
!  Read a rank 2 array of doubles from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R2DOUBLEARR(err,fnum,arr)
!
      IMPLICIT NONE
      REAL(ptdk), POINTER :: arr(:,:)
      INTEGER(ptik) err,fnum,rank,I,J,sizeI,sizeJ,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne.2) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. sizeI*sizeJ) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ))
         DO I = 1, sizeI
           DO J = 1, sizeJ
            CALL CReadXdrDouble(err,fnum,arr(I,J))
            IF (err.ne.0) RETURN
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R2DOUBLEARR
!
!-------------------------------------------------
!  Read a rank 3 array of doubles from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R3DOUBLEARR(err,fnum,arr)
!
      IMPLICIT NONE
      REAL(ptdk), POINTER :: arr(:,:,:)
      INTEGER(ptik) err,fnum,rank,I,J,K,sizeI,sizeJ,sizeK,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne.3) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeK)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. (sizeI*sizeJ*sizeK)) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ,sizeK))
         DO I = 1, sizeI
           DO J = 1, sizeJ
             DO K = 1, sizeK
              CALL CReadXdrDouble(err,fnum,arr(I,J,K))
              IF (err.ne.0) RETURN
             ENDDO
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R3DOUBLEARR
!
!-------------------------------------------------
!  Read a rank 4 array of doubles from the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array read from the file
!
      SUBROUTINE READ_XDR_R4DOUBLEARR(err,fnum,arr)
!
      IMPLICIT NONE
      REAL(ptdk), POINTER :: arr(:,:,:,:)
      INTEGER(ptik) err,fnum,rank,I,J,K,L,sizeI,sizeJ,sizeK,sizeL,totSize
!
      CALL CReadXdrInt(err,fnum, rank)
      IF (err .ne. 0) RETURN
      IF (rank.ne. 4) THEN
         err = -1
         RETURN
      ENDIF
!
      CALL CReadXdrInt(err,fnum, sizeI)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeJ)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeK)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, sizeL)
      IF (err .ne. 0) RETURN
!
      CALL CReadXdrInt(err,fnum, totSize)
      IF (err .ne. 0) RETURN
      IF (totSize .ne. (sizeI*sizeJ*sizeK*sizeL)) THEN
        err = -2
        RETURN
      ENDIF
!
      IF (totSize .eq. 0) THEN
         NULLIFY(arr)
      ELSE
         ALLOCATE (arr(sizeI,sizeJ,sizeK,sizeL))
         DO I = 1, sizeI
           DO J = 1, sizeJ
             DO K = 1, sizeK
               DO L = 1, sizeL
                CALL CReadXdrDouble(err,fnum,arr(I,J,K,L))
                IF (err.ne.0) RETURN
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE READ_XDR_R4DOUBLEARR
!
!-------------------------------------------------
!  Write a String to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value to write to the file.
!  @param length The maximum length of the string.
!
      SUBROUTINE WRITE_XDR_STRING(err,fnum,val,maxLen)
!
      IMPLICIT NONE
      INTEGER(ptik) err,fnum,maxLen
      CHARACTER(LEN=*) val
!
      CALL CWriteXdrString(err,fnum,TRIM(val)//CHAR(0),maxLen)
!
      END SUBROUTINE WRITE_XDR_STRING
!
!-------------------------------------------------
!  Write a raw byte array to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value to write to the file.
!  @param length The maximum length of the byte array.
!
      SUBROUTINE WRITE_XDR_BYTES(err,fnum,val,maxLen)
!
      IMPLICIT NONE
      INTEGER(ptik) err,fnum,maxLen
      CHARACTER(LEN=*) val
!
      CALL CWriteXdrBytes(err,fnum,val,maxLen);
!
      END SUBROUTINE WRITE_XDR_BYTES
!
!-------------------------------------------------
!  Write an integer to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value to write to the file.
!
      SUBROUTINE WRITE_XDR_INT(err,fnum, val)
      IMPLICIT NONE
      INTEGER(ptik) err,fnum,val
      CALL CWriteXdrInt(err,fnum,val);
      END SUBROUTINE WRITE_XDR_INT
!
!-------------------------------------------------
!  Write a 64-bit integer to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value to write to the file.
!
      SUBROUTINE WRITE_XDR_INT64(err,fnum, val)
      IMPLICIT NONE
      INTEGER(ptik) err,fnum
      INTEGER(ptlk) val
      CALL CWriteXdrInt64(err,fnum,val);
      END SUBROUTINE WRITE_XDR_INT64
!
!-------------------------------------------------
!  Write a logical to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value to write to the file.
!
      SUBROUTINE WRITE_XDR_LOGICAL(err,fnum, val)
      IMPLICIT NONE
      INTEGER(ptik) err,fnum,i
      LOGICAL val
      IF (val) THEN
         i = 1
      ELSE
         i = 0
      ENDIF
      CALL CWriteXdrInt(err,fnum,i);
      END SUBROUTINE WRITE_XDR_LOGICAL
!
!-------------------------------------------------
!  Write a float to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value to write to the file.
!
      SUBROUTINE WRITE_XDR_FLOAT(err,fnum,val)
      IMPLICIT NONE
      REAL val
      INTEGER err,fnum
      CALL CWriteXdrFloat(err,fnum,val);
      END SUBROUTINE WRITE_XDR_FLOAT
!
!-------------------------------------------------
!  Write a double to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The value to write to the file.
!
      SUBROUTINE WRITE_XDR_DOUBLE(err,fnum,val)
      IMPLICIT NONE
      REAL(ptdk) val
      INTEGER err,fnum
      CALL CWriteXdrDouble(err,fnum,val);
      END SUBROUTINE WRITE_XDR_DOUBLE
!
!-------------------------------------------------
!  Write an array of Strings to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!  @param length The maximum length of a string.
!
      SUBROUTINE WRITE_XDR_STRINGARR(err,fnum,val,maxLen)
!
      IMPLICIT NONE
      INTEGER(ptik) err,fnum,maxLen,I
      CHARACTER(LEN=*), POINTER, DIMENSION(:) :: val
!
      IF (ASSOCIATED(val)) THEN
         CALL CWriteXdrInt(err,fnum,SIZE(val))
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
            CALL CWriteXdrString(err,fnum,TRIM(val(I))//CHAR(0),maxLen)
            IF (err.ne.0) RETURN
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,0_ptik)
      ENDIF
!
      END SUBROUTINE WRITE_XDR_STRINGARR
!
!-------------------------------------------------
!  Write an array of integers to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_INTARR(err,fnum,val)
!
      IMPLICIT NONE
      INTEGER(ptik), POINTER, DIMENSION(:) :: val
      INTEGER(ptik) err,fnum,I
!
      IF (ASSOCIATED(val)) THEN
         CALL CWriteXdrInt(err,fnum,SIZE(val))
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
            CALL CWriteXdrInt(err,fnum,val(I))
            IF (err.ne.0) RETURN
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,0_ptik)
      ENDIF
!
      END SUBROUTINE WRITE_XDR_INTARR
!
!-------------------------------------------------
!  Write an array of logicals to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_LOGICALARR(err,fnum,val)
!
      IMPLICIT NONE
      LOGICAL, POINTER, DIMENSION(:) :: val
      INTEGER(ptik) err,fnum,I
!
      IF (ASSOCIATED(val)) THEN
         CALL CWriteXdrInt(err,fnum,SIZE(val))
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
            CALL WRITE_XDR_LOGICAL(err,fnum,val(I))
            IF (err.ne.0) RETURN
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,0_ptik)
      ENDIF
!
      END SUBROUTINE WRITE_XDR_LOGICALARR
!
!-------------------------------------------------
!  Write an array of doubles to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_FLOATARR(err,fnum,val)
!
      IMPLICIT NONE
      REAL, POINTER, DIMENSION(:) :: val
      INTEGER(ptik) err,fnum,I
!
      IF (ASSOCIATED(val)) THEN
         CALL CWriteXdrInt(err,fnum,SIZE(val))
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
            CALL CWriteXdrFloat(err,fnum,val(I))
            IF (err.ne.0) RETURN
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,0_ptik)
      ENDIF
!
      END SUBROUTINE WRITE_XDR_FLOATARR
!
!-------------------------------------------------
!  Write an array of doubles to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_DOUBLEARR(err,fnum,val)
!
      IMPLICIT NONE
      REAL(ptdk), POINTER, DIMENSION(:) :: val
      INTEGER(ptik) err,fnum,I
!
      IF (ASSOCIATED(val)) THEN
         CALL CWriteXdrInt(err,fnum,SIZE(val))
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
            CALL CWriteXdrDouble(err,fnum,val(I))
            IF (err.ne.0) RETURN
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,0_ptik)
      ENDIF
!
      END SUBROUTINE WRITE_XDR_DOUBLEARR
!
!-------------------------------------------------
!  Write a rank 2 array of integers to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R2INTARR(err,fnum,val)
!
      IMPLICIT NONE
      INTEGER(ptik), POINTER, DIMENSION(:,:) :: val
      INTEGER(ptik) err,fnum,I,J,rank,sizeI,sizeJ,totSize
!
      rank = 2
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         totSize = sizeI*sizeJ
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
            CALL CWriteXdrInt(err,fnum,val(I,J))
            IF (err.ne.0) RETURN
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R2INTARR
!
!-------------------------------------------------
!  Write a rank 3 array of integers to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R3INTARR(err,fnum,val)
!
      IMPLICIT NONE
      INTEGER(ptik), POINTER, DIMENSION(:,:,:) :: val
      INTEGER(ptik) err,fnum,I,J,K,rank,sizeI,sizeJ,sizeK,totSize
!
      rank = 3
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         sizeK = SIZE(val,3)
         totSize = sizeI*sizeJ*sizeK
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeK)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
        IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
             DO K=LBOUND(val,3),UBOUND(val,3)
               CALL CWriteXdrInt(err,fnum,val(I,J,K))
               IF (err.ne.0) RETURN
             ENDDO
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R3INTARR
!
!-------------------------------------------------
!  Write a rank 4 array of integers to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R4INTARR(err,fnum,val)
!
      IMPLICIT NONE
      INTEGER(ptik), POINTER, DIMENSION(:,:,:,:) :: val
      INTEGER(ptik) err,fnum,I,J,K,L,rank,sizeI,sizeJ,sizeK,sizeL,totSize
!
      rank = 4
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         sizeK = SIZE(val,3)
         sizeL = SIZE(val,4)
         totSize = sizeI*sizeJ*sizeK*sizeL
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeK)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeL)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
             DO K=LBOUND(val,3),UBOUND(val,3)
               DO L=LBOUND(val,4),UBOUND(val,4)
                 CALL CWriteXdrInt(err,fnum,val(I,J,K,L))
                 IF (err.ne.0) RETURN
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R4INTARR
!
!-------------------------------------------------
!  Write a rank 2 array of logicals to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R2LOGICALARR(err,fnum,val)
!
      IMPLICIT NONE
      LOGICAL, POINTER, DIMENSION(:,:) :: val
      INTEGER(ptik) err,fnum,I,J,rank,sizeI,sizeJ,totSize
!
      rank = 2
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         totSize = sizeI*sizeJ
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
            CALL WRITE_XDR_LOGICAL(err,fnum,val(I,J))
            IF (err.ne.0) RETURN
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R2LOGICALARR
!
!-------------------------------------------------
!  Write a rank 3 array of logicals to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R3LOGICALARR(err,fnum,val)
!
      IMPLICIT NONE
      LOGICAL, POINTER, DIMENSION(:,:,:) :: val
      INTEGER(ptik) err,fnum,I,J,K,rank,sizeI,sizeJ,sizeK,totSize
!
      rank = 3
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         sizeK = SIZE(val,3)
         totSize = sizeI*sizeJ*sizeK
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeK)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
        IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
             DO K=LBOUND(val,3),UBOUND(val,3)
               CALL WRITE_XDR_LOGICAL(err,fnum,val(I,J,K))
               IF (err.ne.0) RETURN
             ENDDO
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R3LOGICALARR
!
!-------------------------------------------------
!  Write a rank 4 array of logicals to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R4LOGICALARR(err,fnum,val)
!
      IMPLICIT NONE
      LOGICAL, POINTER, DIMENSION(:,:,:,:) :: val
      INTEGER(ptik) err,fnum,I,J,K,L,rank,sizeI,sizeJ,sizeK,sizeL,totSize
!
      rank = 4
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         sizeK = SIZE(val,3)
         sizeL = SIZE(val,4)
         totSize = sizeI*sizeJ*sizeK*sizeL
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeK)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeL)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
             DO K=LBOUND(val,3),UBOUND(val,3)
               DO L=LBOUND(val,4),UBOUND(val,4)
                 CALL WRITE_XDR_LOGICAL(err,fnum,val(I,J,K,L))
                 IF (err.ne.0) RETURN
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R4LOGICALARR
!
!-------------------------------------------------
!  Write a rank 2 array of floats to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R2FLOATARR(err,fnum,val)
!
      IMPLICIT NONE
      REAL, POINTER, DIMENSION(:,:) :: val
      INTEGER(ptik) err,fnum,I,J,rank,sizeI,sizeJ,totSize
!
      rank = 2
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         totSize = sizeI*sizeJ
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
             CALL CWriteXdrFloat(err,fnum,val(I,J))
             IF (err.ne.0) RETURN
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R2FLOATARR
!
!-------------------------------------------------
!  Write a rank 3 array of floats to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R3FLOATARR(err,fnum,val)
!
      IMPLICIT NONE
      REAL, POINTER, DIMENSION(:,:,:) :: val
      INTEGER(ptik) err,fnum,I,J,K,rank,sizeI,sizeJ,sizeK,totSize
!
      rank = 3
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         sizeK = SIZE(val,3)
         totSize = sizeI*sizeJ*sizeK
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeK)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
             DO K=LBOUND(val,3),UBOUND(val,3)
               CALL CWriteXdrFloat(err,fnum,val(I,J,K))
               IF (err.ne.0) RETURN
             ENDDO
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R3FLOATARR
!
!-------------------------------------------------
!  Write a rank 4 array of floats to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R4FLOATARR(err,fnum,val)
!
      IMPLICIT NONE
      REAL, POINTER, DIMENSION(:,:,:,:) :: val
      INTEGER(ptik) err,fnum,I,J,K,L,rank,sizeI,sizeJ,sizeK,sizeL,totSize
!
      rank = 4
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         sizeK = SIZE(val,3)
         sizeL = SIZE(val,4)
         totSize = sizeI*sizeJ*sizeK*sizeL
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeK)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeL)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
             DO K=LBOUND(val,3),UBOUND(val,3)
               DO L=LBOUND(val,4),UBOUND(val,4)
                 CALL CWriteXdrFloat(err,fnum,val(I,J,K,L))
                 IF (err.ne.0) RETURN
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R4FLOATARR
!
!-------------------------------------------------
!  Write a rank 2 array of doubles to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R2DOUBLEARR(err,fnum,val)
!
      IMPLICIT NONE
      REAL(ptdk), POINTER, DIMENSION(:,:) :: val
      INTEGER(ptik) err,fnum,I,J,rank,sizeI,sizeJ,totSize
!
      rank = 2
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         totSize = sizeI*sizeJ
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
            CALL CWriteXdrDouble(err,fnum,val(I,J))
            IF (err.ne.0) RETURN
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R2DOUBLEARR
!
!-------------------------------------------------
!  Write a rank 3 array of doubles to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R3DOUBLEARR(err,fnum,val)
!
      IMPLICIT NONE
      REAL(ptdk), POINTER, DIMENSION(:,:,:) :: val
      INTEGER(ptik) err,fnum,I,J,K,rank,sizeI,sizeJ,sizeK,totSize
!
      rank = 3
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         sizeK = SIZE(val,3)
         totSize = sizeI*sizeJ*sizeK
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeK)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
             DO K=LBOUND(val,3),UBOUND(val,3)
               CALL CWriteXdrDouble(err,fnum,val(I,J,K))
               IF (err.ne.0) RETURN
             ENDDO
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R3DOUBLEARR
!
!-------------------------------------------------
!  Write a rank 4 array of doubles to the PIB file.
!
!  @param err Contains error flag on return.
!  @param val The array write to the file.
!
      SUBROUTINE WRITE_XDR_R4DOUBLEARR(err,fnum,val)
!
      IMPLICIT NONE
      REAL(ptdk), POINTER, DIMENSION(:,:,:,:) :: val
      INTEGER(ptik) err,fnum,I,J,K,L,rank,sizeI,sizeJ,sizeK,sizeL,totSize
!
      rank = 4
      IF (ASSOCIATED(val)) THEN
         sizeI = SIZE(val,1)
         sizeJ = SIZE(val,2)
         sizeK = SIZE(val,3)
         sizeL = SIZE(val,4)
         totSize = sizeI*sizeJ*sizeK*sizeL
!
         CALL CWriteXdrInt(err,fnum,rank)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeI)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeJ)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeK)
         IF (err.ne.0) RETURN
         CALL CWriteXdrInt(err,fnum,sizeL)
         IF (err.ne.0) RETURN
!
         CALL CWriteXdrInt(err,fnum,totSize)
         IF (err.ne.0) RETURN
         DO I=LBOUND(val,1),UBOUND(val,1)
           DO J=LBOUND(val,2),UBOUND(val,2)
             DO K=LBOUND(val,3),UBOUND(val,3)
               DO L=LBOUND(val,4),UBOUND(val,4)
                 CALL CWriteXdrDouble(err,fnum,val(I,J,K,L))
                 IF (err.ne.0) RETURN
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ELSE
         CALL CWriteXdrInt(err,fnum,rank)
         DO I=1,rank+1
            CALL CWriteXdrInt(err,fnum,0_ptik)
         ENDDO
      ENDIF
!
      END SUBROUTINE WRITE_XDR_R4DOUBLEARR
!
!-------------------------------------------------
!  Perform a deep copy of a string array.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_STRINGARR(toArr,from,length)
      IMPLICIT NONE
      INTEGER(ptik) :: I,length
      CHARACTER(LEN=length),POINTER,DIMENSION(:) :: toArr
      CHARACTER(LEN=length),POINTER,DIMENSION(:) :: from
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE(toArr(LBOUND(from,1):UBOUND(from,1)))
         DO I=LBOUND(from,1),UBOUND(from,1)
            toArr(i)=from(i)
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_STRINGARR
!
!-------------------------------------------------
!  Perform a deep copy of an integer array.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_INTARR(toArr,from)
      IMPLICIT NONE
      INTEGER(ptik) I
      INTEGER(ptik),POINTER :: toArr(:)
      INTEGER(ptik),POINTER :: from(:)
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE(toArr(LBOUND(from,1):UBOUND(from,1)))
         DO I=LBOUND(from,1),UBOUND(from,1)
            toArr(i)=from(i)
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_INTARR
!
!-------------------------------------------------
!  Perform a deep copy of a logical array.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_LOGICALARR(toArr,from)
      IMPLICIT NONE
      INTEGER(ptik) I
      LOGICAL,POINTER :: toArr(:)
      LOGICAL,POINTER :: from(:)
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE(toArr(LBOUND(from,1):UBOUND(from,1)))
         DO I=LBOUND(from,1),UBOUND(from,1)
            toArr(i)=from(i)
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_LOGICALARR
!
!-------------------------------------------------
!  Perform a deep copy of a float array.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_FLOATARR(toArr,from)
      IMPLICIT NONE
      INTEGER(ptik) I
      REAL,POINTER :: toArr(:)
      REAL,POINTER :: from(:)
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE(toArr(LBOUND(from,1):UBOUND(from,1)))
         DO I=LBOUND(from,1),UBOUND(from,1)
            toArr(i)=from(i)
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_FLOATARR
!
!-------------------------------------------------
!  Perform a deep copy of a double array.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_DOUBLEARR(toArr,from)
      IMPLICIT NONE
      INTEGER(ptik) I
      REAL(ptdk),POINTER :: toArr(:)
      REAL(ptdk),POINTER :: from(:)
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE(toArr(LBOUND(from,1):UBOUND(from,1)))
         DO I=LBOUND(from,1),UBOUND(from,1)
            toArr(i)=from(i)
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_DOUBLEARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 2 array of integers.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R2INTARR(toArr,from)
!
      IMPLICIT NONE
      INTEGER(ptik),POINTER :: toArr(:,:)
      INTEGER(ptik),POINTER :: from(:,:)
      INTEGER(ptik) I,J
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
            toArr(I,J) = from(I,J)
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R2INTARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 2 array of logicals.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R2LOGICALARR(toArr,from)
!
      IMPLICIT NONE
      LOGICAL,POINTER :: toArr(:,:)
      LOGICAL,POINTER :: from(:,:)
      INTEGER(ptik) I,J
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
            toArr(I,J) = from(I,J)
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R2LOGICALARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 2 array of floats.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R2FLOATARR(toArr,from)
!
      IMPLICIT NONE
      REAL,POINTER :: toArr(:,:)
      REAL,POINTER :: from(:,:)
      INTEGER(ptik) I,J
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
            toArr(I,J) = from(I,J)
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R2FLOATARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 2 array of doubles.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R2DOUBLEARR(toArr,from)
!
      IMPLICIT NONE
      REAL(ptdk),POINTER :: toArr(:,:)
      REAL(ptdk),POINTER :: from(:,:)
      INTEGER(ptik) I,J
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
            toArr(I,J) = from(I,J)
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R2DOUBLEARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 3 array of integers.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R3INTARR(toArr,from)
!
      IMPLICIT NONE
      INTEGER(ptik),POINTER :: toArr(:,:,:)
      INTEGER(ptik),POINTER :: from(:,:,:)
      INTEGER(ptik) I,J,K
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2), &
     &                LBOUND(from,3):UBOUND(from,3)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
             DO K=LBOUND(from,3),UBOUND(from,3)
               toArr(I,J,K) = from(I,J,K)
             ENDDO
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R3INTARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 3 array of logicals.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R3LOGICALARR(toArr,from)
!
      IMPLICIT NONE
      LOGICAL,POINTER :: toArr(:,:,:)
      LOGICAL,POINTER :: from(:,:,:)
      INTEGER(ptik) I,J,K
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2), &
     &                LBOUND(from,3):UBOUND(from,3)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
             DO K=LBOUND(from,3),UBOUND(from,3)
               toArr(I,J,K) = from(I,J,K)
             ENDDO
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R3LOGICALARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 3 array of floats.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R3FLOATARR(toArr,from)
!
      IMPLICIT NONE
      REAL,POINTER :: toArr(:,:,:)
      REAL,POINTER :: from(:,:,:)
      INTEGER(ptik) I,J,K
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2), &
     &                LBOUND(from,3):UBOUND(from,3)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
             DO K=LBOUND(from,3),UBOUND(from,3)
               toArr(I,J,K) = from(I,J,K)
             ENDDO
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R3FLOATARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 3 array of doubles.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R3DOUBLEARR(toArr,from)
!
      IMPLICIT NONE
      REAL(ptdk),POINTER :: toArr(:,:,:)
      REAL(ptdk),POINTER :: from(:,:,:)
      INTEGER(ptik) I,J,K
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2), &
     &                LBOUND(from,3):UBOUND(from,3)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
             DO K=LBOUND(from,3),UBOUND(from,3)
               toArr(I,J,K) = from(I,J,K)
             ENDDO
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R3DOUBLEARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 4 array of integers.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R4INTARR(toArr,from)
!
      IMPLICIT NONE
      INTEGER(ptik),POINTER :: toArr(:,:,:,:)
      INTEGER(ptik),POINTER :: from(:,:,:,:)
      INTEGER(ptik) I,J,K,L
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2), &
     &                LBOUND(from,3):UBOUND(from,3),LBOUND(from,4):UBOUND(from,4)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
             DO K=LBOUND(from,3),UBOUND(from,3)
               DO L=LBOUND(from,4),UBOUND(from,4)
                 toArr(I,J,K,L) = from(I,J,K,L)
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R4INTARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 4 array of logicals.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R4LOGICALARR(toArr,from)
!
      IMPLICIT NONE
      LOGICAL,POINTER :: toArr(:,:,:,:)
      LOGICAL,POINTER :: from(:,:,:,:)
      INTEGER(ptik) I,J,K,L
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2), &
     &                LBOUND(from,3):UBOUND(from,3),LBOUND(from,4):UBOUND(from,4)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
             DO K=LBOUND(from,3),UBOUND(from,3)
               DO L=LBOUND(from,4),UBOUND(from,4)
                 toArr(I,J,K,L) = from(I,J,K,L)
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R4LOGICALARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 4 array of floats.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R4FLOATARR(toArr,from)
!
      IMPLICIT NONE
      REAL,POINTER :: toArr(:,:,:,:)
      REAL,POINTER :: from(:,:,:,:)
      INTEGER(ptik) I,J,K,L
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2), &
     &                LBOUND(from,3):UBOUND(from,3),LBOUND(from,4):UBOUND(from,4)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
             DO K=LBOUND(from,3),UBOUND(from,3)
               DO L=LBOUND(from,4),UBOUND(from,4)
                 toArr(I,J,K,L) = from(I,J,K,L)
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R4FLOATARR
!
!-------------------------------------------------
!  Perform a deep copy of a rank 4 array of doubles.
!
!  @param toArr The destination for the new array.
!  @param from The original array to be deep copied.
!
      SUBROUTINE DEEPCOPY_R4DOUBLEARR(toArr,from)
!
      IMPLICIT NONE
      REAL(ptdk),POINTER :: toArr(:,:,:,:)
      REAL(ptdk),POINTER :: from(:,:,:,:)
      INTEGER(ptik) I,J,K,L
!
      IF(ASSOCIATED(toArr)) THEN
         DEALLOCATE(toArr)
         NULLIFY(toArr)
      ENDIF
!
      IF (ASSOCIATED(from)) THEN
         ALLOCATE (toArr(LBOUND(from,1):UBOUND(from,1),LBOUND(from,2):UBOUND(from,2), &
     &                LBOUND(from,3):UBOUND(from,3),LBOUND(from,4):UBOUND(from,4)))
         DO I=LBOUND(from,1),UBOUND(from,1)
           DO J=LBOUND(from,2),UBOUND(from,2)
             DO K=LBOUND(from,3),UBOUND(from,3)
               DO L=LBOUND(from,4),UBOUND(from,4)
                 toArr(I,J,K,L) = from(I,J,K,L)
               ENDDO
             ENDDO
           ENDDO
         ENDDO
      ENDIF
      END SUBROUTINE DEEPCOPY_R4DOUBLEARR
!
      END MODULE XDR
