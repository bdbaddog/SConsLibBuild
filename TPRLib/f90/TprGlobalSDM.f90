      MODULE TprGlobalSD
!
! -------------------- NOTE: DO NOT EDIT THIS FILE. --------------------
! This file is generated.  Modifications will be lost!
! Generated by PIBTOOL
! ----------------------------------------------------------------------
!
!     BEGIN MODULE USE
      USE PibIntrType
      USE CPibFaces
      USE Xdr
!
!  This module provides IO access to GlobalSDT data bocks.
      TYPE GlobalSDT
!       Current version number.
        INTEGER(ptik) :: VER_ = 6
!
!       Current problem or restart time.
        REAL(ptdk) :: eTime = -1.0E30_ptdk
!
!       Current timestep number.
        INTEGER(ptik) :: nstep = -99119900_ptik
!
!       Number of outer iterations this timestep.
        INTEGER(ptik) :: oitno = -99119900_ptik
!
!       Total timesteps since the beginning.
        INTEGER(ptik) :: totTimeSteps = -99119900_ptik
!
!       Current TimeStep Size.
        REAL(ptdk) :: delt = -1.0E30_ptdk
!
!       Total CPU time elapsed.
        REAL(ptdk) :: cpuTot = -1.0E30_ptdk
!
!       Maximum ratio between Courant number and TimeStep size for 1D components this timestep.
        REAL(ptdk) :: vMaxT = -1.0E30_ptdk
!
!       Maximum ratio between Courant number and TimeStep size for 1D components last timestep.
        REAL(ptdk) :: vMaxO = -1.0E30_ptdk
!
!       Maximum ratio between Courant number and TimeStep size for 3D components this timestep.
        REAL(ptdk) :: vMaxT3 = -1.0E30_ptdk
!
!       Maximum ratio between Courant number and TimeStep size for 3D components last timestep.
        REAL(ptdk) :: vMxT3O = -1.0E30_ptdk
!
!       Vessel water mass this timestep (liquid + vapor).
        REAL(ptdk) :: vmNew = -1.0E30_ptdk
!
!       Vessel water mass last timestep (liquid + vapor).
        REAL(ptdk) :: vmOld = -1.0E30_ptdk
!
!       Net water mass convectedINTo Vessel components this timestep.
        REAL(ptdk) :: vmCon = -1.0E30_ptdk
!
!       Maximum decrease in void fraction this timestep.
        REAL(ptdk) :: dal = -1.0E30_ptdk
!
!       Maximum increase in void fraction this timestep.
        REAL(ptdk) :: dau = -1.0E30_ptdk
!
!       Maximum decrease in void fraction this timestep that was immediately preceeded by
!       an increase.
        REAL(ptdk) :: oal = -1.0E30_ptdk
!
!       Maximum increase in void fraction this timestep that was immediately preceeded by
!       an decrease.
        REAL(ptdk) :: oau = -1.0E30_ptdk
!
!       TimeStep limit that results in maximum allowable valve adjustment.
        REAL(ptdk) :: delXMx = -1.0E30_ptdk
!
!       TimeStep limit that results in maximum change in core power (10%).
        REAL(ptdk) :: delPMx = -1.0E30_ptdk
!
!       Maximum pressure change during this timestep.
        REAL(ptdk) :: dPrMx = -1.0E30_ptdk
!
!       Maximum liquid-temperature change during this timestep.
        REAL(ptdk) :: dTlMx = -1.0E30_ptdk
!
!       Maximum HTSTR temperature chnage this timestep.
        REAL(ptdk) :: dTrMx = -1.0E30_ptdk
!
!       Maximum gas-temperature change during this timestep.
        REAL(ptdk) :: dTvMx = -1.0E30_ptdk
!
!       logical variable denoting that power is on in the Heat structures.
        LOGICAL :: powerTurnedOn = .false.
!
!       Maximum variable error.
        REAL(ptdk) :: varerm = -1.0E30_ptdk
!
!       SETS 3D evaluation flag for all 3D components (vessels).
        INTEGER(ptik) :: nStab = -99119900_ptik
!
!       SETS 3D evaluation flag for all 3D components (vessels) during the last timestep.
        INTEGER(ptik) :: nStabO = -99119900_ptik
!
!       Initial time zero fluid mass in the complete model.
        REAL(ptdk) :: initialMass = -1.0E30_ptdk
!
!       Current total system fluid mass.
        REAL(ptdk) :: finalMass = -1.0E30_ptdk
!
!       Time integrated break mass flow rate.
        REAL(ptdk) :: integratedBreak = -1.0E30_ptdk
!
!       Time integrated FILL mass flow rate.
        REAL(ptdk) :: integratedFill = -1.0E30_ptdk
!
!       Time integrated PRIZER mass flow rate.
        REAL(ptdk) :: integratedPrizer = -1.0E30_ptdk
!
!       Initial time zero non-condensible gas system mass.
        REAL(ptdk) :: initialNCGMass = -1.0E30_ptdk
!
!       Current system non-condensible gas mass.
        REAL(ptdk) :: finalNCGMass = -1.0E30_ptdk
!
!       Time integrated non-condensible gas mass flow rate.
        REAL(ptdk) :: integratedNCGBreak = -1.0E30_ptdk
!
!       Time integrated non-condensible gas FILL mass flow rate.
        REAL(ptdk) :: integratedNCGFill = -1.0E30_ptdk
!
!       Time integrated non-condensible gas mass flow rate for the PRIZERs.
        REAL(ptdk) :: integratedNCGPrizer = -1.0E30_ptdk
!
!       Flag to permit timestep control for radial heat conduction.
        REAL(ptdk) :: con2min = 1.0E8_ptdk
!
!       number of attempted time step restores (if still in region of reduced dtMax).
        REAL(ptdk) :: backupAttempts = -1.0E30_ptdk
!
!       problem time of last save point.
        REAL(ptdk) :: eTimeLastSave = -1.0E30_ptdk
!
!       value of temporary maximum delt.
        REAL(ptdk) :: dtMaxTemp = -1.0E30_ptdk
!
!       time at which to relax dtMaxTemp.
        REAL(ptdk) :: dropDtMaxEnd = -1.0E30_ptdk
!
!       System initial solute mass.
        REAL(ptdk) :: initialSoluteMass = -1.0E30_ptdk
!
!       Time integrated solute flow out BREAKs.
        REAL(ptdk) :: integratedSoluteBreak = -1.0E30_ptdk
!
!       Time integrated solute flow into FILLs.
        REAL(ptdk) :: integratedSoluteFill = -1.0E30_ptdk
!
!       Time integrated solute flow out of PRIZER.
        REAL(ptdk) :: integratedSolutePrizer = -1.0E30_ptdk
!
!       Current system solute mass.
        REAL(ptdk) :: finalSoluteMass = -1.0E30_ptdk
!
!       Current system solute mass that is plated out and in solids form.
        REAL(ptdk) :: finalSoluteSolids = -1.0E30_ptdk
!
!       Surface wave limit.
        REAL(ptdk) :: surfWaveLimit = -1.0E30_ptdk
      END TYPE GlobalSDT
!
      CONTAINS
!
!------------------------------------------------------------
!  Read a GlobalSDT data block from file.
!
!  @param err Contains an error flag on return.
!
!  @param CMPRS_ The block size in bytes prior to compression
!                or -1 if the block is not compressed.
!
!  @param VER_ The block version.
!
!  @return The GlobalSDT data block.
!------------------------------------------------------------
      SUBROUTINE readGlobalSDT(err,fnum,block,CMPRS_,VER_)
!
      IMPLICIT NONE
      INTEGER(ptik) :: err,fnum,CMPRS_,VER_
      TYPE(GlobalSDT) :: block
!       Obsolete fields
        REAL(ptdk) :: legacy__0_dTsMx
!
!     CHECK FOR COMPRESSION
      IF (CMPRS_ > 0) THEN
!        Error, compression not supported.
      ELSE
         SELECT CASE (VER_)
            CASE (0)
            CALL READ_XDR_DOUBLE(err,fnum,block%eTime)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nstep)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%oitno)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%totTimeSteps)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delt)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%cpuTot)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT3)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMxT3O)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmNew)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmOld)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmCon)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delXMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delPMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dPrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTlMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,legacy__0_dTsMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTvMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_LOGICAL(err,fnum,block%powerTurnedOn)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%varerm)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStab)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStabO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CASE (1)
            CALL READ_XDR_DOUBLE(err,fnum,block%eTime)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nstep)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%oitno)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%totTimeSteps)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delt)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%cpuTot)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT3)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMxT3O)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmNew)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmOld)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmCon)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delXMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delPMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dPrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTlMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,legacy__0_dTsMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTvMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_LOGICAL(err,fnum,block%powerTurnedOn)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%varerm)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStab)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStabO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CASE (2)
            CALL READ_XDR_DOUBLE(err,fnum,block%eTime)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nstep)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%oitno)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%totTimeSteps)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delt)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%cpuTot)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT3)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMxT3O)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmNew)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmOld)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmCon)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delXMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delPMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dPrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTlMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,legacy__0_dTsMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTvMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_LOGICAL(err,fnum,block%powerTurnedOn)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%varerm)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStab)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStabO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%con2min)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CASE (3)
            CALL READ_XDR_DOUBLE(err,fnum,block%eTime)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nstep)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%oitno)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%totTimeSteps)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delt)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%cpuTot)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT3)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMxT3O)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmNew)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmOld)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmCon)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delXMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delPMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dPrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTlMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,legacy__0_dTsMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTvMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_LOGICAL(err,fnum,block%powerTurnedOn)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%varerm)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStab)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStabO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%con2min)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%backupAttempts)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%eTimeLastSave)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dtMaxTemp)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dropDtMaxEnd)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CASE (4)
            CALL READ_XDR_DOUBLE(err,fnum,block%eTime)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nstep)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%oitno)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%totTimeSteps)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delt)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%cpuTot)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT3)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMxT3O)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmNew)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmOld)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmCon)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delXMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delPMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dPrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTlMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,legacy__0_dTsMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTvMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_LOGICAL(err,fnum,block%powerTurnedOn)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%varerm)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStab)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStabO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%con2min)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%backupAttempts)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%eTimeLastSave)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dtMaxTemp)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dropDtMaxEnd)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialSoluteMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedSoluteBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedSoluteFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedSolutePrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalSoluteMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalSoluteSolids)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CASE (5)
            CALL READ_XDR_DOUBLE(err,fnum,block%eTime)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nstep)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%oitno)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%totTimeSteps)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delt)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%cpuTot)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT3)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMxT3O)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmNew)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmOld)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmCon)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delXMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delPMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dPrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTlMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,legacy__0_dTsMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTvMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_LOGICAL(err,fnum,block%powerTurnedOn)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%varerm)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStab)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStabO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%con2min)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%backupAttempts)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%eTimeLastSave)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dtMaxTemp)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dropDtMaxEnd)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialSoluteMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedSoluteBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedSoluteFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedSolutePrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalSoluteMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalSoluteSolids)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%surfWaveLimit)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CASE (6)
            CALL READ_XDR_DOUBLE(err,fnum,block%eTime)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nstep)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%oitno)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%totTimeSteps)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delt)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%cpuTot)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMaxT3)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vMxT3O)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmNew)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmOld)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%vmCon)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oal)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%oau)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delXMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%delPMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dPrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTlMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTrMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dTvMx)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_LOGICAL(err,fnum,block%powerTurnedOn)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%varerm)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStab)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_INT(err,fnum,block%nStabO)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalNCGMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedNCGPrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%con2min)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%backupAttempts)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%eTimeLastSave)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dtMaxTemp)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%dropDtMaxEnd)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%initialSoluteMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedSoluteBreak)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedSoluteFill)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%integratedSolutePrizer)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalSoluteMass)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%finalSoluteSolids)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CALL READ_XDR_DOUBLE(err,fnum,block%surfWaveLimit)
            IF (err.ne.0) THEN
               RETURN
            ENDIF
            CASE DEFAULT
!               Error, version not supported.
         END SELECT
      ENDIF
!
      END SUBROUTINE readGlobalSDT
!
!------------------------------------------------------------
!  Write a GlobalSDT data block to file.
!
!  @param err Contains an error flag on return.
!
!  @param block The GlobalSDT block to be written.
!------------------------------------------------------------
      SUBROUTINE writeGlobalSDT(err,fnum, block)
      IMPLICIT NONE
      INTEGER(ptik) err,fnum
      TYPE(GlobalSDT) :: block
!
      CALL OPENPIBBLOCK(err,fnum,'GlobalSD'//CHAR(0),6)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%eTime)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_INT(err,fnum,block%nstep)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_INT(err,fnum,block%oitno)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_INT(err,fnum,block%totTimeSteps)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%delt)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%cpuTot)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%vMaxT)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%vMaxO)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%vMaxT3)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%vMxT3O)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%vmNew)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%vmOld)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%vmCon)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%dal)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%dau)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%oal)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%oau)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%delXMx)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%delPMx)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%dPrMx)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%dTlMx)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%dTrMx)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%dTvMx)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_LOGICAL(err,fnum,block%powerTurnedOn)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%varerm)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_INT(err,fnum,block%nStab)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_INT(err,fnum,block%nStabO)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%initialMass)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%finalMass)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%integratedBreak)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%integratedFill)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%integratedPrizer)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%initialNCGMass)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%finalNCGMass)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%integratedNCGBreak)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%integratedNCGFill)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%integratedNCGPrizer)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%con2min)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%backupAttempts)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%eTimeLastSave)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%dtMaxTemp)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%dropDtMaxEnd)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%initialSoluteMass)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%integratedSoluteBreak)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%integratedSoluteFill)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%integratedSolutePrizer)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%finalSoluteMass)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%finalSoluteSolids)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL WRITE_XDR_DOUBLE(err,fnum,block%surfWaveLimit)
      IF (err.ne.0) THEN
         RETURN
      ENDIF
      CALL CLOSEPIBBLOCK(err,fnum)
!
      END SUBROUTINE writeGlobalSDT
!
!------------------------------------------------------------
!  Free allocated memory for a GlobalSDT data block.
!
!  @param err Contains an error flag on return.
!
!  @param block The GlobalSDT block to be freed.
!------------------------------------------------------------
      SUBROUTINE freeGlobalSDT(err,block)
      IMPLICIT NONE
      INTEGER(ptik) :: err,stat
      TYPE(GlobalSDT) :: block
!
      err = 0
!
!
      END SUBROUTINE freeGlobalSDT
!
!------------------------------------------------------------
!  Dump a GlobalSDT data block in ASCII.
!
!  @param un The file unit where the block will be written.
!
!  @param block The GlobalSDT block to be written.
!------------------------------------------------------------
      SUBROUTINE dumpGlobalSDT(un,block)
      IMPLICIT NONE
      INTEGER(ptik) :: un
      TYPE(GlobalSDT) :: block
!
      WRITE(un,'(a)')'BLOCK GlobalSDT VERSION 6'
      WRITE(un,"('     eTime=',G12.4)")block%eTime
      WRITE(un,"('     nstep=',I12)")block%nstep
      WRITE(un,"('     oitno=',I12)")block%oitno
      WRITE(un,"('     totTimeSteps=',I12)")block%totTimeSteps
      WRITE(un,"('     delt=',G12.4)")block%delt
      WRITE(un,"('     cpuTot=',G12.4)")block%cpuTot
      WRITE(un,"('     vMaxT=',G12.4)")block%vMaxT
      WRITE(un,"('     vMaxO=',G12.4)")block%vMaxO
      WRITE(un,"('     vMaxT3=',G12.4)")block%vMaxT3
      WRITE(un,"('     vMxT3O=',G12.4)")block%vMxT3O
      WRITE(un,"('     vmNew=',G12.4)")block%vmNew
      WRITE(un,"('     vmOld=',G12.4)")block%vmOld
      WRITE(un,"('     vmCon=',G12.4)")block%vmCon
      WRITE(un,"('     dal=',G12.4)")block%dal
      WRITE(un,"('     dau=',G12.4)")block%dau
      WRITE(un,"('     oal=',G12.4)")block%oal
      WRITE(un,"('     oau=',G12.4)")block%oau
      WRITE(un,"('     delXMx=',G12.4)")block%delXMx
      WRITE(un,"('     delPMx=',G12.4)")block%delPMx
      WRITE(un,"('     dPrMx=',G12.4)")block%dPrMx
      WRITE(un,"('     dTlMx=',G12.4)")block%dTlMx
      WRITE(un,"('     dTrMx=',G12.4)")block%dTrMx
      WRITE(un,"('     dTvMx=',G12.4)")block%dTvMx
      IF (block%powerTurnedOn) THEN
        WRITE(un,"('     powerTurnedOn= TRUE')")
      ELSE
        WRITE(un,"('     powerTurnedOn= FALSE')")
      ENDIF
      WRITE(un,"('     varerm=',G12.4)")block%varerm
      WRITE(un,"('     nStab=',I12)")block%nStab
      WRITE(un,"('     nStabO=',I12)")block%nStabO
      WRITE(un,"('     initialMass=',G12.4)")block%initialMass
      WRITE(un,"('     finalMass=',G12.4)")block%finalMass
      WRITE(un,"('     integratedBreak=',G12.4)")block%integratedBreak
      WRITE(un,"('     integratedFill=',G12.4)")block%integratedFill
      WRITE(un,"('     integratedPrizer=',G12.4)")block%integratedPrizer
      WRITE(un,"('     initialNCGMass=',G12.4)")block%initialNCGMass
      WRITE(un,"('     finalNCGMass=',G12.4)")block%finalNCGMass
      WRITE(un,"('     integratedNCGBreak=',G12.4)")block%integratedNCGBreak
      WRITE(un,"('     integratedNCGFill=',G12.4)")block%integratedNCGFill
      WRITE(un,"('     integratedNCGPrizer=',G12.4)")block%integratedNCGPrizer
      WRITE(un,"('     con2min=',G12.4)")block%con2min
      WRITE(un,"('     backupAttempts=',G12.4)")block%backupAttempts
      WRITE(un,"('     eTimeLastSave=',G12.4)")block%eTimeLastSave
      WRITE(un,"('     dtMaxTemp=',G12.4)")block%dtMaxTemp
      WRITE(un,"('     dropDtMaxEnd=',G12.4)")block%dropDtMaxEnd
      WRITE(un,"('     initialSoluteMass=',G12.4)")block%initialSoluteMass
      WRITE(un,"('     integratedSoluteBreak=',G12.4)")block%integratedSoluteBreak
      WRITE(un,"('     integratedSoluteFill=',G12.4)")block%integratedSoluteFill
      WRITE(un,"('     integratedSolutePrizer=',G12.4)")block%integratedSolutePrizer
      WRITE(un,"('     finalSoluteMass=',G12.4)")block%finalSoluteMass
      WRITE(un,"('     finalSoluteSolids=',G12.4)")block%finalSoluteSolids
      WRITE(un,"('     surfWaveLimit=',G12.4)")block%surfWaveLimit
      WRITE(un,'(a)')'END BLOCK GlobalSDT'
!
      END SUBROUTINE dumpGlobalSDT
!
!------------------------------------------------------------
!  Perform a deep copy of a GlobalSDT data block.
!
!  @param toblock The GlobalSDT destination block.
!
!  @param fromblock The GlobalSDT block to be deep copied.
!------------------------------------------------------------
      SUBROUTINE copyGlobalSDT(toblock,fromblock)
      IMPLICIT NONE
      TYPE(GlobalSDT) :: toblock
      TYPE(GlobalSDT) :: fromblock
!
      toblock%eTime=fromblock%eTime
      toblock%nstep=fromblock%nstep
      toblock%oitno=fromblock%oitno
      toblock%totTimeSteps=fromblock%totTimeSteps
      toblock%delt=fromblock%delt
      toblock%cpuTot=fromblock%cpuTot
      toblock%vMaxT=fromblock%vMaxT
      toblock%vMaxO=fromblock%vMaxO
      toblock%vMaxT3=fromblock%vMaxT3
      toblock%vMxT3O=fromblock%vMxT3O
      toblock%vmNew=fromblock%vmNew
      toblock%vmOld=fromblock%vmOld
      toblock%vmCon=fromblock%vmCon
      toblock%dal=fromblock%dal
      toblock%dau=fromblock%dau
      toblock%oal=fromblock%oal
      toblock%oau=fromblock%oau
      toblock%delXMx=fromblock%delXMx
      toblock%delPMx=fromblock%delPMx
      toblock%dPrMx=fromblock%dPrMx
      toblock%dTlMx=fromblock%dTlMx
      toblock%dTrMx=fromblock%dTrMx
      toblock%dTvMx=fromblock%dTvMx
      toblock%powerTurnedOn=fromblock%powerTurnedOn
      toblock%varerm=fromblock%varerm
      toblock%nStab=fromblock%nStab
      toblock%nStabO=fromblock%nStabO
      toblock%initialMass=fromblock%initialMass
      toblock%finalMass=fromblock%finalMass
      toblock%integratedBreak=fromblock%integratedBreak
      toblock%integratedFill=fromblock%integratedFill
      toblock%integratedPrizer=fromblock%integratedPrizer
      toblock%initialNCGMass=fromblock%initialNCGMass
      toblock%finalNCGMass=fromblock%finalNCGMass
      toblock%integratedNCGBreak=fromblock%integratedNCGBreak
      toblock%integratedNCGFill=fromblock%integratedNCGFill
      toblock%integratedNCGPrizer=fromblock%integratedNCGPrizer
      toblock%con2min=fromblock%con2min
      toblock%backupAttempts=fromblock%backupAttempts
      toblock%eTimeLastSave=fromblock%eTimeLastSave
      toblock%dtMaxTemp=fromblock%dtMaxTemp
      toblock%dropDtMaxEnd=fromblock%dropDtMaxEnd
      toblock%initialSoluteMass=fromblock%initialSoluteMass
      toblock%integratedSoluteBreak=fromblock%integratedSoluteBreak
      toblock%integratedSoluteFill=fromblock%integratedSoluteFill
      toblock%integratedSolutePrizer=fromblock%integratedSolutePrizer
      toblock%finalSoluteMass=fromblock%finalSoluteMass
      toblock%finalSoluteSolids=fromblock%finalSoluteSolids
      toblock%surfWaveLimit=fromblock%surfWaveLimit
!
      END SUBROUTINE copyGlobalSDT
!
      END MODULE TprGlobalSD
